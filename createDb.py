#!/usr/bin/python3
#Author: Emmanuel Odeke <odeke@ualberta.ca>
import sqlite3, re

from os import stat, path  
from time import ctime
from sqlite3 import connect, OperationalError
from hashlib import md5

####################CONSTANTS####################
TABLE_ALREADY_EXISTS = 0xf
TABLE_CREATED = ( ~TABLE_ALREADY_EXISTS )
current_file_search = re.search('.*/(\w+\.py)$',__file__)
if current_file_search:
  current_file_name = current_file_search.groups(1)[0]
else: #Hard coded value here
  current_file_name = 'createDb.py'
#################################################
def create_monitor_time_src():
  #This creates the file from which the first database creation date is stored
  #This date is essential to keep tracking of when track-monitoring began
  MONITOR_START_SOURCE = "monitor_start.py"
  sDate = open(MONITOR_START_SOURCE,'w')
  sDate.write('#This file was auto-generated by %s\n'%(current_file_name ))
  sDate.write('MONITOR_START_DATE = "%s"\n'%(ctime()))
  sDate.flush()
  sDate.close()

#Create the storage database if none existant
def getConCursor( dbPath ):
  if ( not path.exists( dbPath )):
    create_monitor_time_src()
    f = open( dbPath, "w" )
    f.close()

  conn = connect( dbPath ) 
  cur  = conn.cursor()
  createTable( 'songs', conn )
  return conn, cur

def createTable( tableName, cursor ):
  try:
    cursor.execute( "CREATE TABLE songs( artist text, title text, trackHash text, playTimes )" )
    cursor.commit()
  except OperationalError as e:
    return TABLE_ALREADY_EXISTS

  return TABLE_CREATED

def lookupQuery( title, artist, cursor ):
  cursor.execute( 'SELECT playTimes FROM songs where title=? AND artist=?', ( title, artist ))
  results = cursor.fetchone()
  return results

def addEntry( tableName, entry, cursor ):
  artist,title,trackHash,newPlayTime = entry
  queryPlayTimes = lookupQuery( title, artist, cursor )
  if ( queryPlayTimes ):
    recorded_times = list( queryPlayTimes )
    joinedTimes  = ' '.join( recorded_times )
    #print( joinedTimes )
    if ( newPlayTime not in  joinedTimes ):
       recorded_times.append( newPlayTime )
       convStrTimes = ' '.join( [ str( i ) for  i in recorded_times ] )
       cursor.execute( 'UPDATE songs set playTimes=? where artist=? AND trackHash=?', 
       ( convStrTimes, artist, trackHash ))
          
    return;
  cursor.execute( 'INSERT INTO songs VALUES( ?,?,?,? )', 
                ( artist,title, trackHash,newPlayTime )) 
def first( a ):
  return a[0]

def last( a ):
  return a[-1]

def rankTracks( cursor ):
  UNIMPORTED_MONITOR = True
  while UNIMPORTED_MONITOR:
    try:
      import monitor_start
    except ImportError as e:
      create_monitor_time_src()
    except Exception:
      sys.stderr.write( "Fatal error: " )
      sys.stderr.write( e.msg )
      sys.exit(-10)
    else:
      UNIMPORTED_MONITOR = False
  cursor.execute( 'SELECT * FROM songs' )
  ranks = dict()
  ranksStr = ''
  for row in cursor.execute( 'SELECT * FROM songs' ):
    artist,title,trackHash,playTimes = row
    listPTimes = re.findall( r'(\d+)', playTimes )
    nTimes = len( listPTimes )
    listPTimes.insert( 0, nTimes )
    ranks[ tuple( listPTimes) ] = ( title, artist )
  rankKeys = sorted( list( ranks.keys()), reverse=True )
  i = 1
  nLine =  ( '*'*80 ).center( 100, ' ' )
  ranksStr +=  'TopPlayed Tracks by the BearRocks.com'.center( 100, ' '  )+'\n'
  ranksStr +=  ( 'as last updated at: %s. Monitored from %s'%( ctime(), 
	  monitor_start.MONITOR_START_DATE) ).center( 100, ' ' ) + '\n'
  ranksStr +=  nLine +'\n'
  ranksStr +=  '{h:<4} {pos:>5}  {t:<40}  {a:<40}{pTs:<25}\n'.format( 
      h='#', pos='Rank', pTs='PlayCounts',t='Title',a='Artist' )
  lastLen = 0
  realPos = 1
  for eachKey in rankKeys:
    title,artist = ranks[eachKey]
    count,pTimes = eachKey[0],eachKey[1:]
    if ( lastLen != count ):
      realPos = i
    ranksStr +=  '{seqPos:<5} {pos:<5} {t:<40} {a:<40} {pTs}\n'.format( seqPos=i, 
      pos=realPos, pTs=count,t=title,a=artist )
    i+=1
    lastLen = count

  return ranksStr
def main():
  dbPath = "songDatabase1.db" 
  conn,cursor = getConCursor( dbPath )
  rankTracks( cursor )

if __name__ == '__main__':
  main()
